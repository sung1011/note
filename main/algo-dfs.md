# 深度优先算法 Deep First Search (DFS)

## DFS 的目标

1. 从起始节点开始, 以深度优先遍历的方式, 搜索整个图, 直到找到目标节点.
2. 从起始节点开始, 以深度优先遍历的方式, 搜索整个图, 直到找到满足条件的所有节点.

## DFS 的特点

1. 从起始节点开始, 逐层向下扩展, 直到找到目标节点.
2. 通过递归实现, 递归栈的方式, 保证每个节点只访问一次.

## DFS 的应用场景

1. 图的遍历 访问图或树中的所有节点，每个节点都被访问一次且仅访问一次。
2. 寻找路径问题 在图或树中找到从源节点到目标节点的路径.
3. 拓扑排序
4. 集合分解问题

## DFS 的实现步骤

1. 选择一个节点作为起始节点, 访问该节点.
2. 递归访问该节点的未访问过的相邻节点.
3. 重复步骤 2, 直到找到目标节点或满足条件的所有节点.

## DFS 的代码实现

```python
def dfs(graph, start, visited=None):
    if visited is None:
        visited = set()
    visited.add(start)
    for next in graph[start] - visited:
        dfs(graph, next, visited)
    return visited
```

## DFS 的时间复杂度

1. 对于有 $V$ 个节点, $E$ 条边的图, 时间复杂度为 $O(V+E)$.
2. 对于无向图, $E$ 的最大值为 $V(V-1)/2$, 时间复杂度为 $O(V^2)$.
3. 对于有向图, $E$ 的最大值为 $V(V-1)$, 时间复杂度为 $O(V^2)$.

## BFS vs DFS

### BFS 和 DFS 的比较

1. BFS 和 DFS 都是图的搜索算法.
2. BFS 采用的是先进先出的方式, DFS 采用的是先进后出的方式.
3. BFS 适用于搜索最短路径, DFS 适用于搜索全部路径.
4. BFS 的空间复杂度较高, DFS 的空间复杂度较低.
5. BFS 的时间复杂度较高, DFS 的时间复杂度较低.

> DFS 的空间复杂度通常比 BFS 低。因为在搜索过程中，DFS 只需要存储一条路径上的节点，而 BFS 需要存储整个搜索边界的节点。因此，当需要搜索的路径数量非常多时，DFS 通常更加高效。

### BFS 和 DFS 的应用场景

1. BFS 适用于求最短路径的问题.
2. DFS 适用于求全部路径的问题.
3. BFS 可以用来判断图的连通性.
4. DFS 可以用来判断图的强连通性.

### 总结

1. 广度优先算法 Breadth First Search (BFS) 是一种图的搜索算法.
2. 通过队列实现, 先进先出(FIFO), 保证每个节点只访问一次.
3. 适用于搜索最短路径, 求全部路径, 判断图的连通性, 判断图的强连通性.
4. 时间复杂度为 $O(V+E)$, 空间复杂度较高.
5. 深度优先算法 Depth First Search (DFS) 是另一种图的搜索算法.
6. 通过递归实现,