# TCP

## 标志位  

- **SYN** synchronous 建立联机
- **ACK** acknowledgement(确认) 向对方发送确认
- **PSH** push(传送) 接收端尽快传送数据到应用层, 不必等缓冲区满再发送.
- **FIN** finish(结束) 结束连接
- **RST** reset(重置) 告知对方可以重置状态(清空端口值数据)
- **URG** urgent(紧急)

- **seq** Sequence number(顺序号码)
- **ack** Acknowledge number(确认号码)

## 通讯流程

### 三次握手

```bash
    C -------------------------> S: `SYN` seq=j # 在吗, 我要联机
  SYN_SEND                    SYN_RCVD


    C <------------------------- S: `ACK` ack=j+1, `SYN` seq=k # ok, 在
  ESTABLISHED


    C -------------------------> S: `ACK` ack=k+1 # ok, 建立连接吧
                            ESTABLISHED
```

> 当第一次握手出现网络延迟, 第二次握手依然会正常响应(但C端已认为过期), 这时第三次握手就会被抛弃, S端没收到第三次握手就不会建立连接.  

> 反之, 若无第三次握手, S端会在第二次握手就开始建立C端已经认为过期抛弃的连接, 浪费资源.

> SYN_RCVD [syn_ack flood](ddos.md)

### 四次挥手

```bash
    C --------------------> S: `FIN` seq=i # 可以关吗
 FIN_WAIT1              CLOSE_WAIT (并发请求太多, 处理不过来)


    C <-------------------- S: `ACK` ack=i+1 # ok收到, 稍等, 我还有返回没发完呢
 FIN_WAIT2 (半关闭连接.C端进入只收不发状态)
                        CLOSE_WAIT


    C <-------------------- S: `FIN` seq=j # (发完了)可以关了
 TIME_WAIT              LAST_ACK (压测时C端突然断开, S端很多LAST_ACK


    C --------------------> S: `ACK` ack=j+1 # ok, 我关了, 你也关吧. (并且轮询几下检测是否真断了)
  CLOSED
                        CLOSED
```

> 第二, 三次挥手的意义在于, 服务端还在处理数据无法立即关闭socket, 故只能先回复一个ACK确认.  

> 第四次挥手会进入time_wait状态, 在 2MSL 时间点发送ACK (以保障连接中C的最后一个ACK和S的最后一个FIN都已消失)

> MSL: maximum segment lifetime 报文最大生存时间 30s~60s

## 流量控制

```bash
# 无流量控制

# S端接收C端的数据后进行缓存, 并持续消费缓存数据
# 缓存区已满时, 数据会被丢弃
               2k
    C --------------------> S   2k/4k
    C <-------------------- S
               ack

               2k
    C --------------------> S   4k/4k
    C <-------------------- S
               ack

               2k
    C --------------------> S   4k/4k 缓存区已满, 丢弃
```

```bash
# 流量控制

# 控制C的发送流量, 从而使S来的及接受和处理数据
# S端每次收到数据包后, 返回缓存区剩余多少空间(接收窗口rwnd)
# C端将其设置为发送流量的上限(发送窗口cwnd)
# 由于S端同时也在持续的消费缓存区的数据, 所以cwnd<当前缓存区剩余空间

# cwnd=0时, 设置定时器, 定时探测rwnd的变化
               2k
    C --------------------> S   2k/4k
    C <-------------------- S
           ack,rwnd=2k
cwnd=2k

               2k
    C --------------------> S   3k/4k   3k=2-1+2 S消费了1k
    C <-------------------- S
           ack,rwnd=1k
cwnd=1k

               1k
    C --------------------> S   4k/4k   4k=3-1+2 S消费了1k
    C <-------------------- S
           ack,rwnd=0k
cwnd=0停止发送, 设置定时器

            试探包文
    C --------------------> S   3k/4k   2k=4-1 S消费了1k
    C <-------------------- S
           ack,rwnd=1k
cwnd>0, 继续发送
```


## 拥塞控制

![img](res/tcp-flow-limit.png)

    控制C的并发量, 避免网络负载过大

- 慢开始 与 拥塞避免 (废弃)

```bash
# 慢开始

# 由小逐渐翻倍变大cwnd
cwnd=1k
    C --------------------> S
    C <-------------------- S

cwnd=2k
    C --------------------> S
    C <-------------------- S

cwnd=4k
    C --------------------> S
    C <-------------------- S

# 拥塞避免

# 当cwnd>=一个熵值(ssthresh)时 从慢开始算法转为拥塞避免算法
# cwnd从翻倍 变为 cwnd+=1k (加法增大)
# 假设ssthresh=16k
cwnd=16k
    C --------------------> S
    C <-------------------- S


cwnd=17k
    C --------------------> S
    C <-------------------- S

cwnd=18k
    C --------------------> S
    C <-------------------- S

# 网络拥塞

# 减半ssthresh (乘法减小), 并缓慢ssthresh+1 (加法增大), cwnd重置为1
cwnd=18k
    C --------------------> S  出现拥塞 (没有按时收到ack)
    C <-------------------- S
           慢ack,rwnd=0
cwnd=1k, ssthresh=9k (出现网络拥塞时的窗口大小的一半 (cwnd/2 = 18/2))

cwnd=1k
    C --------------------> S
    C <-------------------- S
           慢ack,rwnd=x
cwnd=2k, ssthresh=10k = 9k+1k

```

- 快重传 与 快恢复

```bash
# 快重传

# 不设置定时器, 3次ack后马上重传丢失的数据包#2
# 重传后不进行慢开始(cwnd=1) 而是设置为与ssthresh相等(cwnd=ssthresh)
                #1
    C --------------------> S
    C <-------------------- S

                #2
    C ----------X           S

                #3
    C --------------------> S
    C <-------------------- S
                #2呢?

                #4
    C --------------------> S
    C <-------------------- S
                #2呢?

                #5
    C --------------------> S
    C <-------------------- S
                #2呢?

                #2   询问3次后 快速重传#2
    C --------------------> S
    C <-------------------- S
cwnd=9k(与sthresh相等), ssthresh=9k (出现网络拥塞时的窗口大小的一半 (cwnd/2 = 18/2))
```

> "快重传+快恢复"相比"慢开始+拥塞避免", 重传更快(不用等计时器), 窗口恢复更合理(cwnd不用重置为1, 而是重置为ssthresh相同的值)

## 粘包 拆包

- 粘包 C同时发送多个数据包, tcp将其打包成一个TCP包文发送; 通过TCP发送缓冲区
- 拆包 C发送的TCP数据包超过传输最大值, 会被拆包

```bash
# 假如发送缓冲区/接收缓冲区容量都是5
                    send buffer (cap=5)                           recv buffer (cap=5)
        C -----------> < aabbb > -------------TCP连接-------------> < iijkk > -----------------> S
            aaaa         (粘包)      bcccc ccccc ccdde efghi                       kk lll m nnn... (拆包)
```

> HTTP协议会帮助处理粘包/拆包, 基于TCP自定义协议需要关注粘包/拆包问题.

## ref

- tcp状态 <https://blog.csdn.net/wuji0447/article/details/78356875>
- 理解TCP <https://www.jianshu.com/p/ca64764e4a26>
- TCP流量控制,拥塞控制 <https://zhuanlan.zhihu.com/p/37379780>
- 流量控制 <https://www.cnblogs.com/kubidemanong/p/9987810.html>
