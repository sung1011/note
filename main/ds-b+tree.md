# b+tree

```js
    基于平衡二叉树
    每个节点可拥有多个子节点
    中间节点不存储value(数据), 只存储key(索引), value都在叶子节点里.
    某中间节点左子树key < 某中间节点的key <= 某中间节点右子树key
    每个叶子节点都有兄弟叶子的指针
    设某个b+tree为 m 阶b+tree
    m/2 <= k <= m-1 (同btree)


                5 28 65
                [] [] []         # 不存数据, 只存指针
                /    |     \
    5 10 20     28 35 56     65 80 90
    [] [] []     [] [] []     [] [] []
    /    |   \    /  |    \    /   |   \
    5    10  20  28  35   56  65   80   90  # 叶子存放数据
    8    15  26  30  38   60  73   88   96
    9    18  27  33  50   63  79   89   99
    next next ..  ..  ..   ..  ..   ..   .. # 指针指向下一组叶子数据
```

## 场景

    树形低矮IO少, 速度稳定, 便于遍历

## 特征

- `擅长遍历` 每个叶子节点都有兄弟叶子的指针
- `数据在叶子` 中间节点不存储value(数据), 只存储key(索引), value都在叶子节点里
- `某中间节点左子树key < 某中间节点的key <= 某中间节点右子树key`
- `一般每个中间节点的大小限定为磁盘一个簇的大小, 充分优化磁盘碎片空间`

> 磁盘最小读写单位是扇区, 操作系统一次会最少读写多个扇区, 这些扇区称为 块 block/簇 cluster

## 操作

- `find O(log n)` 通过key在树中进行二分查找.

- `insert O(log n)`

- `delete O(log n)`

## 实战

- MySQL

## 对比

### vs B-tree

```md
# 优势

  1. 因为节点中无数据, 单一节点存储的元素更多, 树更低矮, IO更少.(实践中 3层就可以千万级别数据)
  2. 所有查询都要从根查到叶子节点, 速度更稳定.
  3. 叶子节点链表, 便于范围(遍历)查找 和 临近数据查找.

> 一个4k节点的内部可以存400个元素, 那么一个4层的B+tree能存400^4=256亿个元素.

# 劣势

  1. b+tree由于数据在叶子节点, 每次插入新数据都需要随机写入磁盘, 速度慢. --- [LSM](ds-LSM.md)将多次单页随机写变成一次多页顺序写.
```

### vs mysql

```js
1. 每个节点的大小等于磁盘一个簇的大小(4k)
2. 前3层中间节点常驻在内存中

# > 第一层4k, 第二层400^4k = 1.6M, 第三层160000^4k = 640M
```

## ref

- [二叉树](ds-binary-tree.md)  

- [二叉搜索树](ds-binary-search-tree.md)  

- [平衡二叉树](ds-AVL-tree.md)

- [b-tree](ds-b-tree.md)

- <https://segmentfault.com/a/1190000020416577>
