# 哈希 hash

## 概念

    对象转为数字, 作为数组下标.

> 这里的数组, 也称作 散列表 哈希表

## 算法 特征

    输入不固定长度字符, 输出固定长度字符
    输入相同, 返回相同
    kv查询
    算法不可逆

## 结构

```js
ht0:
    0 --> 496 --> 896
    1 --> 1 --> 337 -> 353
    2
    3 --> 387
    4
    5
    6 --> 184 --> 212 --> 424 --> 488 --> 867
    7
    8 --> 26 --> 155
    9
    ...

ht1: 
    ...

# `单向链表` 从小到大排序的单向链表

# `ht1` 在rehash时, 将ht0的数据迁移过来
```

## 数据结构 特征

- `快 find O(1)`

- `hash冲突, 冲突后速度降级`

- `无序, 不利于遍历`

> hash填充率:  即`负载因子 load factor` = 元素个数 / 哈希表长度; 约0.5比较好.

## 哈希算法冲突

### 解决冲突1 分配足够大的array

    减少冲突概率

```js
    预先分配/动态分配足够的array的长度.
```

### 解决冲突2 开放寻址法

    使哈希值分布更均匀; 适合静态数据

#### 线性探查 Linear Probing

```js
    `insert` 遇到冲突后, 顺序查看array的`下一个位置`是否empty, empty就insert, 非empty就继续向后查.

    `find` 遇到冲突后, 顺序查看array的`下一个位置`是否=key, !=key就继续向后查, 直到查到empty为止, 认定为未查到.
```

#### 二次探查 Quadratic Probing

```js
    【线性探查】的改良, 线性顺序查找(步长i)改为`跨越查找(步长i^n)`.如第二次i^2, 第三次i^3...
```

#### 双散列 Double Hash

```js
    【线性探查】的改良, 使用`多种hash函数`来求下标位置.如有冲突则用第二种hash函数计算下标, 依然冲突则用第三种hash函数计算下标.
```

> [布隆过滤器 Bloom filter](algo-bloomfilter.md)

> 随着元素增多, 查询速度不可控, 运气不好一直查不到时, 最坏导致遍历 O(n).  

> 随着元素增多, 迟早会占满array, 占满后进行更低效的 `rehash` 过程

### 解决冲突3 链表法

    冲突后提供解决方案; 适合动态数据

```js
    array中不存储具体元素, 而是存储一个`链表头 linkedlist head`, 冲突后push到链表尾部.
    链表过长时, `rehash` 或 `转化为二叉树/跳表/红黑树`.
```

## 操作

todo
