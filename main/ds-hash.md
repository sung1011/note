# 哈希 hash

## 概念

    对象转为数字，作为数组下标。

> 这里的数组，也称作 散列表 哈希表

## 特征

- `快 find O(1)`

- `hash冲突， 冲突后速度降级`

- `无序，不利于遍历`

> hash填充率： 即`负载因子 load factor` = 元素个数 / 哈希表长度; 约0.5比较好。

### 解决冲突1 分配足够大的array -- 减少冲突概率

    预先分配/动态分配足够的array的长度。

### 解决冲突2 开放寻址法 -- 使哈希值分布更均匀; 适合静态数据

#### 线性探查 Linear Probing

    insert: 遇到冲突后，顺序查看array的`下一个位置`是否empty，empty就insert，非empty就继续向后查。

    find: 遇到冲突后，顺序查看array的`下一个位置`是否=key，!=key就继续向后查，直到查到empty为止，认定为未查到。

#### 二次探查 Quadratic Probing

    【线性探查】的改良，线性顺序查找（步长i）改为`跨越查找(步长i^n)`。如第二次i^2，第三次i^3...

#### 双散列 Double Hash

    【线性探查】的改良，使用`多种hash函数`来求下标位置。如有冲突则用第二种hash函数计算下标，依然冲突则用第三种hash函数计算下标。

> 随着元素增多，查询速度不可控，运气不好一直查不到时，最坏导致遍历 O(n)。  
> 随着元素增多，迟早会占满array，占满后进行更低效的 `rehash` 过程

### 解决冲突3 链表法 -- 冲突后提供解决方案; 适合动态数据

    array中不存储具体元素，而是存储一个`链表头 linkedlist head`，冲突后push到链表尾部。

> 链表过长时，`rehash` 或 `转化为二叉树/跳表/红黑树`。

## 结构

## 操作
