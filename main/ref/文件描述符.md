# 文件描述符

在[ Linux通用I/O模型 ](https://www.jianshu.com/p/5357d72ef17d)中，`I/O`操作系列函数(系统调用)都是围绕一个叫做文件描述符的整数展开。这不禁让人产生疑问：这个整数代表什么？一个数值代表一个文件吗？随便传一个整数进去调用可以吗？

解答以上疑问，需要更深入学习——文件描述符(File Descriptor)。

# 图解

理解具体情况，需要了解由内核维护的3个数据结构：

*   进程级**文件描述符表**(file descriptor table)
*   系统级**打开文件表**(open file table)
*   文件系统**i-node表**(i-node table)

这3个数据结构之间的关系如下图所示：

////-------

## 文件描述符表

内核为每个进程维护一个**文件描述符表**，该表每一条目都记录了单个文件描述符的相关信息，包括：

*   **控制标志**(flags)，目前内核仅定义了一个，即`close-on-exec`

*   **打开文件描述体指针**

## 打开文件表

内核对所有打开的文件维护一个系统级别的**打开文件描述表**(open file description table)，简称**打开文件表**。表中条目称为**打开文件描述体**(open file description)，存储了与一个打开文件相关的全部信息，包括：

*   **文件偏移量**(file offset)，调用`read()`和`write()`更新，调用`lseek()`直接修改
*   **访问模式**，由`open()`调用设置，例如：只读、只写或读写等
*   **`i-node`对象指针**

## i-node表

每个文件系统会为存储于其上的所有文件(包括目录)维护一个`i-node`表，单个`i-node`包含以下信息：

*   **文件类型**(file type)，可以是常规文件、目录、套接字或`FIFO`

*   **访问权限**
*   **文件锁列表**(file locks)
*   **文件大小**
*   等等

`i-node`存储在磁盘设备上，内核在内存中维护了一个副本，这里的**`i-node`表**为后者。副本除了原有信息，还包括：引用计数(从打开文件描述体)、所在设备号以及一些临时属性，例如文件锁。

# 场景解析

上图中，详细描述了两个进程诸多文件描述符，以及相互关系。

## 文件描述符复制

在进程`A`中，文件描述符1和文件描述符20都指向同一个打开文件描述体(标号23)。这很可能是通过调用`dup()`系列函数形成的。

文件描述符复制，在某些场景下非常有用，比如：标准输入/输出重定向。在`shell`下，完成这个操作非常简单，大部分人都会，但是极少人思考过背后的原理。

大概描述一下需要的几个步骤，以标准输出(文件描述符为1)重定向为例：

1.  打开目标文件，返回文件描述符n；
2.  关闭文件描述符1；
3.  调用`dup`将文件描述符n复制到1；
4.  关闭文件描述符n；

## 子进程继承文件描述符

进程`A`的文件描述符2和进程`B`的文件描述符2都指向同一个打开文件描述体(标号73)。这种情形很可能发生在调用`fork()`派生子进程之后，比如`A`调用`fork()`派生出`B`。这时，`B`作为子进程，从父进程`A`继承了文件描述符表，其中包括图中标明的文件描述符2。这就是`子进程继承父进程打开的文件`这句话的由来。

当然了，进程`A`通过`Unix`套接字将一个文件描述符传递给`B`也会出现类似的情形，但一般文件描述符数值是不一样的。同时为2要非常凑巧才发生。
