# redis缓存淘汰

## maxmemory配置触发删除

### 配置

    redis.conf -> maxmemory

### 淘汰策略

#### LRU (Least-Recently-Used)

    redis-server维护24bit全局时钟
    新增/更新key对象时 会将全局时钟赋值给key对象时钟(redisObject.lru:24).
    LRU会对比两个时钟, 淘汰时钟相差最久的

> 只关注过期时间

> 24bit按秒为单位最多存储`194天`, 所以可能出现key时钟大于全局时钟情况. 这时就不是两个相加而是相减来求最久了.

#### LRU策略

1. no-eviction: 则返回错误, 不删除
2. allkeys-lru: 回收最近不使用
3. allkeys-random: 随机回收
4. volatile-lru: 从已设置过期时间的键中, 回收最近不使用
5. volatile-random: 从已设置过期时间的键中, 随机回收
6. volatile-ttl: 从已设置过期时间的键中, 回收即将过期

> `选择` 如数据呈现访问幂律分布, 即一部分访问频率高, 则选择allkeys-lru; 如呈现访问平等分布, 则选择allkeys-random

> `allkeys` 所有键: server.db[i].dict

> `volatile` 已设置过期的键: server.db[i].expires

#### LFU (Least-Frequently-Used)

```js
   # LRU问题
   即使A使用频率比较高, 仍然会在|处被LRU淘汰, redis4.0+的LFU策略解决这一问题.

   A~~A~~A~~A~~A~~A~~A~~A~~A~~A~~~|
   B~~~~~B~~~~~B~~~~~B~~~~~~~~~~~B|
```

> 关注过期时间 和 使用频率

### LFU策略

      LFU将LRU的24bit key对象时钟分为 `16bit时钟` + `8bit计数器`

> 前16bit 依然表示时间, 但单位为小时(2^16=65536h=2730d)

> 后8bit 表示当前key访问频率, 是一个非线性的表达.

```code
+--------+------------+------------+------------+------------+------------+
| factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |
+--------+------------+------------+------------+------------+------------+
| 0      | 104        | 255        | 255        | 255        | 255        |
+--------+------------+------------+------------+------------+------------+
| 1      | 18         | 49         | 255        | 255        | 255        |
+--------+------------+------------+------------+------------+------------+
| 10     | 10         | 18         | 142        | 255        | 255        |
+--------+------------+------------+------------+------------+------------+
| 100    | 8          | 11         | 49         | 143        | 255        |
+--------+------------+------------+------------+------------+------------+
```

#### LFU参数

- `lfu-log-factor` 10 # key命中因子
- `lfu-decay-time` 1  # 控制后8位访问频率递减的时间

## ref

- LRU <http://www.redis.cn/topics/lru-cache.html>
