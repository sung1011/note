# 归并排序

## 概念

```bash
    将无序链表划分为n个子链表
    `子链表` 间 `逐个元素对比排序` 后合并
    递归地进行上一步操作, 最终得到有序链表

    # `子链表` 子链表内永远是有序的  

    # `逐个元素对比排序` 两个链表长度分别为 m 和 n .若无序, 两层遍历进行排序O(m*n); 若有序, 逐个元素对比, 将较小的元素push到新链表 `O(m+n)`  
```

## 场景

    无序链表排序
    多个有序链表合并

## 特征

- `速度稳定`

- `适用于总体无序, 各子项有序`

## 时间

- `optimal` O(k*log(n))
- `worst` O(k*log(n))
- `avg` O(k*log(n))

## 空间

    O(n)

## 操作

```bash
# 原理 分而治之 结构类似完全二叉树
              8 4 5 7 1 3 6 2
             /               \
      8 4 5 7                  1 3 6 2
       /    \                   /    \
    8 4     5 7               1 3     6 2
   /   \    /  \             /  \     /  \
  8    4   5    7           1    3   6    2
   \   /    \  /             \  /     \  /
    4 8     5 7               1 3     2 6
       \    /                   \    /
      4 5 7 8                  1 2 3 6
             \               /
              1 2 3 4 5 6 7 8
```

## 优化归并

- `双链表` 普通归并; 合并有序链表

```bash
# 链表 + 链表 = O(a+b)

            4 5 7 8             # sortedlist a
            1] 2 3 6            # srotedlist b
                            1   # 取 min(a, b)

            4 5 7 8
            2] 3 6
                            1 2
            4 5 7 8
            3] 6
                            1 2 3
            4] 5 7 8
            6
                            1 2 3 4
            5] 7 8
            6
                            1 2 3 4 5
            7 8
            6]
                            1 2 3 4 5 6

                            1 2 3 4 5 6 7 8
```

- `有序链表 + 跳跃表` 其一比较长时

```bash
# 跳跃表a + 链表b = 利用a跳表的索引 O(log(a)) + 在b中遍历 O(b)


            1 2 3 4 ..... 499 500 501 502 503   # skipList a

            1 500 1000                          # list b

# 如: b的500在跟a对比时, 可以利用a的跳跃表, 快步拿到500, 而不必1234...遍历到500
```

- `跳跃表 + 跳跃表 互相二分查找` a, b差不多都挺长时

```bash
# 跳跃表 + 跳跃表 = O(log(a)) + O(log(b))
# 两跳跃表互相二分查找: 当元素a0 < b0, 以b元素做key在a中利用跳表的索引快速往前跳, 反之亦然. O(log(min(a, b)))

            100 200 300 400 500 600 700 800 ... # skipList a

            400 420 440 460 480 800 820 840 ... # skipList b

# 如: b的400 快步跳过a的100~400, a的500 快速跳过b的400~480
```

- `哈希+有序链表` 长链中包含短链(hash)时

```bash
# 哈希a + 链表b = 遍历b中每个元素去a的hash中进行查询, 由于hash查询是O(1), 所以整体是O(b)

            1 2 3 4 ... 999     # list
            1 500 888 999       # hash
```


- `bitmap + bitmap` a, b间隔稠密, 长度有限

```bash
# bitmap + bitmap: 转化为bitmap以方便求交、并、补 O(1).

            1 2 3 4  ... 999    # bitmap
            1 500 888 999       # bitmap
```


## 优化 求交、并、补

- `调整顺序`

      多个集合进行求交、并、差(多路归并)(联合查询)时, 当abc的个数有较大差异, (a ∩ b) ∩ c 和 a ∩ (b ∩ c) 速度有差异, 但都是O(n).

- `快速多路归并`

      利用跳跃表的特性加快多路归并的效率
      如a, b, c, d四个有序链表求交集
      1. 将4个链表第一个元素取出, 其中最大一个元素记为max变量
      2. 从a开始, 如果当前位置的值小于max, 则用`跳表法`快速将指针调整到a中第一个 >= max 的元素位置.新位置元素若 > max, 则更新max.
      3. b, c, d依次执行上一步操作.

    ![img](res/merge-sort-col1.png)
    ![img](res/merge-sort-col2.png)
    ![img](res/merge-sort-col3.png)

- `预先联合`

      若 a ∩ b ∩ c 经常查询, 可以预先将a_b_c作为 [倒排索引](ds-inverted-index.md) 的key, 交集的结果作为值记录在posting list, 查询时直接查询.

    ![img](res/merge-sort-op3.png)

- `缓存加速`

      多个`预先联合`+LRU (least recently used)
      一个简单LRU: 链表head插入缓存元素, tail淘汰元素; 为了快速查询, 在向链表head插入元素的同时, 也向哈希插入key, 对应的value是链表中这个节点的地址.

    ![img](res/merge-sort-op4.png)
