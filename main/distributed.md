# distributed  

## 一致性算法

- [Raft](algo-raft.md)
- Paxos
- PBFT
- [PoW 工作量证明算法](algo-pow.md)
- [PoS 权益证明算法](algo-pos.md)
- [DPos 代表权益证明算法](algo-dpos.md)

## 集群

    多个组件在一起作同样的事。

## 分布式

    多个组件在一起作不同的事。
  
## 事务 (transactions)  

> 可以想象 余额是订单的冗余数据, 同时修改余额和订单, 需要事务

### 隔离级别  

| 隔离级别    | 脏读 DR| 不可重复读 NR | 幻读 PR |
| ----------- | ---- | ---------- | ---- |
| 读未提交 RU | o    | o          | o    |
| 读已提交 RC | x    | o          | o    |
| 可重复读 RR | x    | x          | o    |
| 串行 S      | x    | x          | x    |

> `读未提交` RU read-uncommitted -- 不常见;
>
> `读已提交` RC read-committed -- 非幂等;
>
> `可重复读` RR repeatable-read -- 幂等;
>
> `串行化` serializable -- 不常见; 无并发,性能差,同步锁,无需隔离
>
> `脏读` DR dirty-read
>
> `不可重复读读` NR nonrepeatable-read
>
> `幻读` PR phantom-read

### ACID 四大特性  

- `A 原子性` 即不可分割性,事务要么全部被执行,要么就全部不被执行 -- 行为
- `C 一致性` 数据库从一种正确状态转换成另一种正确状态 -- 状态
- `I 隔离性` 在事务正确提交之前,不允许把该事务对数据的任何改变提供给任何其他事务 -- 独立
- `D 持久性` 事务正确提交后,其结果将永久保存在数据库中,即使在事务提交后有了其他故障,事务的处理结果也会得到保存 -- 保存

> ACI强调的角度不同, 但概念有点杂糅

## CAP  

- `P` (Partition tolerance): 分区容错 --- 指网络故障时两个分区节点是否相同 --- 一般认为P总是成立，剩下的C, A无法同时做到。  
- `C` (Consistency): 一致性 --- 两个实例保证相同状态。
- `A` (Availability): 可用性 --- 两个实例挂掉一个另一个还能提供服务。
- `CP型` 牺牲可用性，保证强一致性。
- `AP型` 牺牲一致性，保证高可用性。
  
## 惊群

多个子进程在同一时刻监听同一个端口造成的资源浪费  
  
## 锁  

### 乐观锁(Optimistic Lock)

顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。  
乐观锁适用于多读的应用类型，这样可以省去锁的开销，提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。  

### 悲观锁(Pessimistic Lock)

顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。  
传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。  
如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，适合上悲观锁。  

