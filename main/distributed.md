# distributed  

## 一致性算法

[Raft](algo-raft.md)

Paxos

PBFT

[PoW 工作量证明算法](algo-pow.md)

[PoS 权益证明算法](algo-pos.md)

[DPos 代表权益证明算法](algo-dpos.md)

## 集群

多个组件在一起作同样的事。

## 分布式

多个组件在一起作不同的事。
  
## 事务 (transactions)  
  
### 隔离级别  

读未提交（read-uncommitted）  
不可重复读（read-committed）  
可重复读（repeatable-read）  
串行化（serializable）  
  
### ACID 四大特性  

原子性 即不可分割性，事务要么全部被执行，要么就全部不被执行。  
一致性 事务的执行使得数据库从一种正确状态转换成另一种正确状态  
隔离性 在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，  
持久性 事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。  
  
## CAP原则  

P (Partition tolerance): 分区容错 --- 一般认为P总是成立，剩下的C, A无法同时做到。
C (Consistency): 一致性 --- 两个实例保证相同状态。
A (Availability): 可用性 --- 两个实例挂掉一个另一个还能提供服务。
  
## 惊群

多个子进程在同一时刻监听同一个端口造成的资源浪费  
  
## 锁  

### 乐观锁(Optimistic Lock)

顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。  
乐观锁适用于多读的应用类型，这样可以省去锁的开销，提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。  

### 悲观锁(Pessimistic Lock)

顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。  
传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。  
如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，适合上悲观锁。  

