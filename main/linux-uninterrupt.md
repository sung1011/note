# 僵尸进程 不可中断进程

## 进程状态

`R Running/Runnalbe` 正在运行, 或在队列中的进程  
`D Disk Sleep` 不可中断 Uninterruptible sleep (usually IO)  

- 进程正在跟硬件交互, 交互过程不允许其他进程或中断打断

`S Interruptible Sleep` 处于可中断休眠状态  

- 因等待某事件而被挂起, 事件发生时会被唤醒

`Z Zombie` 僵尸进程  

- 进程已经结束, 但父进程尚未回收它.

`I Idle` 空闲状态 不可中断睡眠睡眠的内核线程.  

- 对于某些内核线程来说, 有可能并没有任何负载.主要与D区分.
- D状态进程会导致平均负载(loadAverage)升高, 而I状态进程不会.

`T` 停止或被追踪  

- SIGSTOP信号使进程暂停, SIGCONT信号使进程恢复运行. 如:fg

`s` 包含子进程  
`l` 多线程, 克隆线程 multi-threaded (using CLONE_THREAD, like NPTL pthreads do)  
`<` 高优先级  
`N` 低优先级  
`L` 有些页被锁进内存  
`+` 位于前台的进程组  
`W` 进入内存交换(从内核2.6开始无效)  
`X` 死掉的进程  

## 僵尸进程

### 概念

原: 进程退出时, 内核释放该进程所有的资源, 如:打开的文件, 占用的内存; 当一个进程创建了子进程, 父进程无法预知子进程何时结束, 若由于父进程繁忙, 来不及wait, 子进程就结束了, 会丢失子进程结束时的状态信息.  
现: 进程退出时, 保留一些信息, 如:进程号pid,退出状态,运行时间等.这些保留的信息直到进程通过调用wait/waitpid时才会释放.  
故: 如果`没有调用wait/waitpid`或`没有注册SIGCHLD信号处理函数`, 那么保留的信息就不会释放.这种进程就是僵尸进程.  

### 情景

僵尸1: 子进程先结束, 父进程运行中 ---- 但是并未调用wait/waitpid.(父进程wait之前, 算是僵尸进程)
僵尸2: 父进程先结束, 子进程运行中 ---- OS会扫描所有进程寻找刚刚结束的父进程的子进程, 若有, 由init接管成为它的父进程.(init回收之前, 算是僵尸进程, 比较短暂)  
僵尸3: 子进程先结束, 父进程运行中, 但没调用wait就被异常终止 ---- 子进程被init接管成为它的父进程.(init回收之前, 算是僵尸进程)  

## 实战

### [dstat](linux-cmd-dstat.md)

### waitio高(cpu使用率高, 平均负载高), 有D进程, Z进程

1. 优先排查是否磁盘IO.工具dstat, pidstat
2. 等待IO过程不可中断, D状态的进程更可疑
3. 找到可疑进程strace分析
4. 若strace不可分析, 查看进程状态是否Z
5. 抓不到短时进程, 故利用perf记录并分析
6. 若遇大量僵尸进程, pstree找到父进程, 分析是否正常wait或注册SIGCHLD信号处理
