# mysql 拆分

    数据多 分表, 并发高 分库

## 读写分离

    写主节点, 读从节点

### 流程

1. 部署一主多从的DB实例, 并令他们之间实时同步
2. 将读写请求分离到主/从实例上

### 方式

- `C端手工proxy` 修改app dao层, 自定义读写的DB源 -- 代码侵入多
- `C端组件proxy`(*) 第三方组件集成在app中, 代理请求到不同DB -- 代码侵入,性能,稳定性平衡
- `中间件proxy` 中间件伪装成一个单节点实例, 转发请求到真正的DB实例 -- 性能略差,代码侵入少
- `S端proxy` S端接收请求后转发 -- 性能略差

> 高可用负载均衡方案 HAProxy + Keepalived

### issue

- 读写不一致 由于主从同步客观上存在延迟, 所以易出现write后立刻read, 读不到新数据的情况
  - 业务上解决 如:支付后不要立刻跳转到订单
  - 技术上解决 将读写一起请求到主DB(最好包在事务内)

---

## 尾热归档

    具有`尾热效应`的数据, 可以`按时间`拆分成`同构`的`冷热两张表` (如order表)

### 流程

1. 创建表结构相同两张order表
2. 定期按时间将热order部分内容移动归档到冷order
3. 修改部分业务SQL,以支持该拆分

---

## 水平拆分(分片)

      一张大表水平拆分成多张同构小表

### 方式

- 尾数 简单
- 哈希 均匀
- 取余 简单均匀, 但若id有特定规则会出现不均匀
- 范围 如时间; 对查询友好, 容易出现热点
- 查表 自定义映射关系, 灵活, 但需二次查找

### issue

- 按uid主键拆分后, 查询条件是其他字段变得困难 (如: date, orderID)
  - orderID中留出4位保存UID信息, 可算出该orderID在哪个uid分片上
  - 以其他字段做key, 冗余出新的表(类似倒排索引)方便查出order对应的uid
- 分页变得困难

---

## 垂直拆分

    独立业务切分到独立的DB实例
