# linux 协程

    协程是一种`用户态`的轻量级线程, 调度完全由用户控制. (即 用户空间线程)

## 特性

```js
    # 多进程问题
        - `高内存`
        - `难切换`
        ...
        进程切换的开销      |--|     |--|
                        虚拟内存+全局变量+保存usr&sys

    # 多线程问题
        - `高内存` 线程的默认Stack大小是1M
        - `难切换` 线程切换需要保存状态, 涉及用户态+内核态, 所以高CUP运算和高耗时

        Thread0     |----|            |----|
                    task0             task0
        Thread1              |----|
                             task1


        线程切换的开销      |--|     |--|
                            保存usr&sys
                        
        # `线程切换时机` 根据优先级和时间片. 相同优先级, 线程每执行一段时间, 就会中断+切换 (并不是一定执行完才切换). 让渡式切换.


    # 协程
        - `低内存` 每个协程1k
        - `易切换` 协程上下文切换只需要保存`用户态`状态, 低消耗
        - `避免竞争` 在同一个线程顺序执行, `避免竞争`而使用锁

        Thread0    |----| |----| |--|
                   cr0     cr1    cr0       # cr=协程 co-routine


        协程切换的开销    |-|    |-|
                         仅保存usr


    # `协程切换时机` 协作式; 时间片 到期后通知调度器, 调度器根据自己的算法逻辑进行切换调度

    # `协程上下文切换` 线程涉及用户态+内核态, 16个寄存器; 协程只涉及用户态, 3个寄存器

    # `搭配异步IO` 阻塞IO的调用会令整个线程阻塞; 搭配异步IO, 可适用于被阻塞 且 需要高并发的场景; 不适用与计算密集型
```

## 对比

### 单核, 多线程, 协程

- 单核

    单一流程, 一个任务一个任务执行
    进程阻塞浪费CPU

- 多进程 多线程

    设计复杂 同步锁竞争
    高内存占用 线程的默认Stack大小是1M，而协程更轻量，接近1K
    高CPU占用 进程/线程数量越多, 切换越耗时

- 协程 用户线程与内核线程

    1:1 跟多进程/线程一致
    N:1 上下文切换快; 阻塞IO时整个线程阻塞, 无法利用多核
    M:N 上下文切换快, 能够利用多核; 过于依赖协程调度器的优化算法

## ref

- 进程线程协程 <https://www.cnblogs.com/Survivalist/p/11527949.html>
- 什么是协程 <https://zhuanlan.zhihu.com/p/172471249>