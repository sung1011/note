# 调度过程  

![G-P-M](res/gpm)  

## 复用线程

### work-stealing 机制; 偷取

```bash
    # P2空闲; P1非empty
        全局队列 
        =>|             |=>

        G3
        G2

        P1 -- G1     P2
        M1           M2

    # P2从P1偷走G
        全局队列 
        =>|             |=>

        
        G2          

        P1 -- G1     P2 -- `G3`
        M1           M2

    # 如果全局队列中有G, 优先从全局中获取
```

### hand-off 机制; 放手

        G阻塞时, 新调出/调休眠中的M接管P和P的队列, 继续执行

```bash
    # G1阻塞, 导致P1M1空闲了
        全局队列 
        =>|             |=>


        G2           G3

        P1 -- G1     P2
        M1           M2

    # syscall调出M3, 将P1转移到M3, 继续执行G2
        全局队列 
        =>|             |=>


                    G3

        -- G1    P2           `P1` -- `G2`
        M1          M2           M3
      (sleep)

        # > G1阻塞结束后, 会回到其他队列 or 全局队列等待执行
```


## 利用并行

```bash
    调整P的个数 最多个数GOMAXPROCS可配置
    根据CPU占用进行调整 如: CPU/2
```

## 抢占

```bash
    # 协程 让渡
    # cr0时间到后 轮到cr1 然后继续cr0
        Thread0    |----| |----| |----|
                   cr0     cr1    cr0       # cr=协程 co-routine

    # go-routine 抢占
    # gr0时间到后 其他gr抢占
        Thread0    |----| |----| |----|  ... |----|
                   gr0    gr4    gr7         gr0       #cr=go-routine

    # gr 占用的时间片固定10ms
```

## 全局G队列

```bash
    # P2空闲
        全局队列 
        =>|        G4 G5|=>

        
        G3
        G2             
        P1 -- G1     P2
        M1           M2

    # P2优先从全局队列中偷取G
    # 偷取全局队列的过程需要加锁解锁
        全局队列 
        =>|           G4|=>   # lock/unlock

        
        G3
        G2
        P1 -- G1     P2 -- `G5`
        M1           M2

```

---

## 单M  

        单P绑定单M, 顺序执行G

## 多M  

        多P绑定多M, 并行执行G

## 多M多P  

- 如果我们在一个Goroutine中通过go关键字创建了大量G, 这些G虽然暂时会被放在同一个队列, 但如果这时还有空闲P(系统内P的数量默认等于系统cpu核心数), Go运行时系统始终能保证至少有一个(通常也只有一个)活跃的M与空闲P绑定去各种G队列去寻找可运行的G任务, 该种M称为自旋的M.一般寻找顺序为: 自己绑定的P的队列, 全局队列, 然后其他P队列.如果自己P队列找到就拿出来开始运行, 否则去全局队列看看, 由于全局队列需要锁保护, 如果里面有很多任务, 会转移一批到本地P队列中, 避免每次都去竞争锁.如果全局队列还是没有, 就要开始玩狠的了, 直接从其他P队列偷任务了(偷一半任务回来).这样就保证了在还有可运行的G任务的情况下, 总有与CPU核心数相等的M+P组合 在执行G任务或在执行G的路上(寻找G任务).  

## G中存在阻塞IO, 阻塞了M执行  

      Go探测到G1阻塞了M 则将其P转移到其他M (包含G2G3G4...)
      当M阻塞完毕
        M重新寻找一个P去执行G1, 
        若当前无空闲P, 则G1回到Global


> `详细` 在这种情况下, 这个M将会被内核调度器调度出CPU并处于阻塞状态, 与该M关联的其他G就没有办法继续执行了, 但Go运行时系统的一个监控线程(sysmon线程)能探测到这样的M, 并把与该M绑定的P剥离, 寻找其他空闲或新建M接管该P, 然后继续运行其中的G, 大致过程如下图所示.然后等到该M从阻塞状态恢复, 需要重新找一个空闲P来继续执行原来的G, 如果这时系统正好没有空闲的P, 就把原来的G放到全局队列当中, 等待其他M+P组合发掘并执行.  

## 如果某一个G在M运行时间过长, 有没有办法做抢占式调度, 让该M上的其他G获得一定的运行时间, 以保证调度系统的公平性  

- 我们知道linux的内核调度器主要是基于时间片和优先级做调度的. 对于相同优先级的线程, 内核调度器会尽量保证每个线程都能获得一定的执行时间.为了防止有些线程"饿死"的情况, 内核调度器会发起抢占式调度将长期运行的线程中断并让出CPU资源, 让其他线程获得执行机会. 当然在Go的运行时调度器中也有类似的抢占机制, 但并不能保证抢占能成功, 因为Go运行时系统并没有内核调度器的中断能力, 它只能通过向运行时间过长的G中设置抢占flag的方法温柔的让运行的G自己主动让出M的执行权.
- 说到这里就不得不提一下Goroutine在运行过程中可以动态扩展自己线程栈的能力, 可以从初始的2KB大小扩展到最大1G(64bit系统上), 因此在每次调用函数之前需要先计算该函数调用需要的栈空间大小, 然后按需扩展(超过最大值将导致运行时异常).Go抢占式调度的机制就是利用在判断要不要扩栈的时候顺便查看以下自己的抢占flag, 决定是否继续执行, 还是让出自己.  
- 运行时系统的监控线程会计时并设置抢占flag到运行时间过长的G, 然后G在有函数调用的时候会检查该抢占flag, 如果已设置就将自己放入全局队列, 这样该M上关联的其他G就有机会执行了.但如果正在执行的G是个很耗时的操作且没有任何函数调用(如只是for循环中的计算操作), 即使抢占flag已经被设置, 该G还是将一直霸占着当前M直到执行完自己的任务.  

## 对网络IO的优化  

- 将标准库中的网络库全部封装为非阻塞形式, 防止其阻塞底层的M并导致内核调度器切换上下文带来的系统开销.
- 运行时系统加入epoll机制(针对Linux系统), 当某一个Goroutine在进行网络IO操作时, 如果网络IO未就绪, 就将其该Goroutine封装一下, 放入epoll的等待队列中, 当前G挂起, 与其关联的M可以继续运行其他G.当相应的网络IO就绪后, Go运行时系统会将等待网络IO就绪的G从epoll就绪队列中取出(主要在两个地方从epoll中获取已网络IO就绪的G列表, 一是sysmon监控线程中, 二是自旋的M中), 再由调度器将它们像普通的G一样分配给各个M去执行.  
  